package basic

import scalaz.{Coyoneda, Functor, \/, \/-, -\/, ~>, Monad, Applicative, Unapply, Comonad}
import annotation.tailrec
import scalaz.std.function._

object Free extends CopoyoFunctions {

  /** Return from the computation with the given value. */
  case class Return[S[_], A](a: A) extends Free[S, A]

  /** Suspend the computation with the given suspension. */
  case class Suspend[S[_], A](a: S[Free[S, A]]) extends Free[S, A]

  /** A computation that can be stepped through, suspended, and paused */
  type Trampoline[A] = Free[Function0, A]

  /** A free monad over the free functor generated by `S` */
  type FreeC[S[_], A] = Free[({type f[x] = Coyoneda[S, x]})#f, A]

  /** Suspend the given computation in a single step. */
  def return_[S[_], A](value: => A)(implicit S: Applicative[S]): Free[S, A] =
    Suspend[S, A](S.point(Return[S, A](value)))

  /** Suspends a value within a functor in a single step. Monadic unit for a higher-order monad. */
  def liftF[S[_], A](value: => S[A])(implicit S: Functor[S]): Free[S, A] =
    Suspend(S.map(value)(Return[S, A]))

  /** A version of `liftF` that infers the nested type constructor. */
  def liftFU[MA](value: => MA)(implicit MA: Unapply[Functor, MA]): Free[MA.M, MA.A] =
    liftF(MA(value))(MA.TC)

  /** A free monad over a free functor of `S`. */
  def liftFC[S[_], A](s: S[A]): FreeC[S, A] =
    liftFU(Coyoneda lift s)

  implicit def freeMonad[S[_]: Functor] = new Monad[({ type l[A] = Free[S, A] })#l] {
    def point[A](a: => A): Free[S, A] = Return(a)

    def bind[A, B](fa: Free[S, A])(f: A => Free[S, B]): Free[S, B] = fa flatMap f
  }
}


/** A free operational monad for some functor `S`. Binding is done using the heap instead of the stack,
  * allowing tail-call elimination. */
sealed abstract class Free[S[_], A] {
  import Free._

  final def map[B](f: A => B)(implicit S: Functor[S]): Free[S, B] =
    flatMap(a => Return(f(a)))

  /** Alias for `flatMap` */
  final def >>=[B](f: A => Free[S, B])(implicit S: Functor[S]): Free[S, B] = this flatMap f

  /** Binds the given continuation to the result of this computation.
    * All left-associated binds are reassociated to the right. */
  final def flatMap[B](f: A => Free[S, B])(implicit S: Functor[S]): Free[S, B] = this match {
    case Return(a)  => f(a)
    case Suspend(s) => Suspend(S.map(s){ free => free flatMap f })
  }



  /** Evaluates a single layer of the free monad. */
  final def resume(implicit S: Functor[S]): (S[Free[S, A]] \/ A) = this match {
    case Return(a)  => \/-(a)
    case Suspend(t) => -\/(t)
  }

  /** Changes the suspension functor by the given natural transformation. */
  final def mapSuspension[T[_]](f: S ~> T)(implicit S: Functor[S], T: Functor[T]): Free[T, A] =
    resume match {
      case -\/(s) => Suspend(f(S.map(s)(((_: Free[S, A]) mapSuspension f))))
      case \/-(r) => Return(r)
    }

  /**
   * Catamorphism for `Free`.
   * Runs to completion, mapping the suspension with the given transformation at each step and
   * accumulating into the monad `M`.
   */
  final def foldMap[M[_]](f: S ~> M)(implicit S: Functor[S], M: Monad[M]): M[A] =
    this.resume match {
      case -\/(s) => Monad[M].bind(f(s))(_.foldMap(f))
      case \/-(r) => Monad[M].pure(r)
    }


  /** Runs to completion, using a function that extracts the resumption from its suspension functor. */
  final def go(f: S[Free[S, A]] => Free[S, A])(implicit S: Functor[S]): A = {
    @tailrec def go2(t: Free[S, A]): A = t.resume match {
      case -\/(s) => go2(f(s))
      case \/-(r) => r
    }
    go2(this)
  }

  /** Runs a trampoline all the way to the end, tail-recursively. */
  def run(implicit ev: Free[S, A] =:= Trampoline[A]): A =
    ev(this).go(_())

}

object Trampoline {
  import Free._

  def done[A](a: A): Trampoline[A] =
    Free.Return[Function0,A](a)

  def delay[A](a: => A): Trampoline[A] =
    suspend(done(a))

  def suspend[A](a: => Trampoline[A]): Trampoline[A] =
    Free.Suspend[Function0, A](() => a)

  implicit val trampolineInstance: Monad[Trampoline] with Comonad[Trampoline] =
    new Monad[Trampoline] with Comonad[Trampoline] {
      override def point[A](a: => A) = return_[Function0, A](a)
      def bind[A, B](ta: Trampoline[A])(f: A => Trampoline[B]) = ta flatMap f
      def copoint[A](fa: Trampoline[A]) = fa.run
      def cobind[A, B](fa: Trampoline[A])(f: Trampoline[A] => B) = return_[Function0, B](f(fa))
      override def cojoin[A](fa: Trampoline[A]) = Return(fa)
    }

}

trait CopoyoFunctions {
  import scalaz.{Coyoneda, Functor, Unapply}
  import shapeless.ops.coproduct.{Inject, Selector}
  import shapeless.{Coproduct, Inl, Inr, CNil, :+:, Poly1, Id}
  import shapeless.poly._

  class Copoyo[C[_] <: Coproduct] {
    def apply[F[_], A](fa: F[A])(implicit inj: Inject[C[A], F[A]]): Free.FreeC[C, A] =
      Free.liftFC(Coproduct[C[A]](fa))
  }

  object Copoyo {
    def apply[C[_] <: Coproduct] = new Copoyo[C]
  }
}